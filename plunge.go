package main

import (
	"database/sql"
	"fmt"
	"os"
	"strings"
	"time"

	_ "github.com/go-sql-driver/mysql"
	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
)

type Param struct {
	db *sql.DB
	rq string
}

func main() {
	db, err := sql.Open("mysql", "root:123456@tcp(localhost:3307)/stock?charset=utf8mb4")
	if err != nil {
		fmt.Printf("open db err:%s\n", err.Error())
		return
	}
	defer db.Close()
	connStr := "postgres://plunge_user:anzfESMqiahYgw9yzXRVoBpBIvsge2CH@dpg-cgfsfj02qv28tc10h2rg-a.oregon-postgres.render.com/plunge"
	//connStr := "postgres://plunge671_8f96_user:oNMXb2FdPOhEgnDjjEoNwiabbQ1MZOvL@dpg-cehaopun6mpg3l60rlu0-a.oregon-postgres.render.com/plunge671_8f96"
	//connStr := "postgres://fexfcxkdkqtwtv:d78c4cd945f357f0b1675d4676e36acfaa0c67b71a893888e7adb2fc0e610ea0@ec2-44-206-137-96.compute-1.amazonaws.com:5432/ddm81443irf0t9"

	pdb, perr := sqlx.Connect("postgres", connStr)
	// pdb, perr := sql.Open("postgres", connStr)
	if perr != nil {
		fmt.Printf("open db perr:%s\n", perr.Error())
		return
	}
	defer pdb.Close()

	start := time.Now().UnixNano()

	rq := "2023-01-19"
	tname := "dayline"
	if len(os.Args) != 3 {
		fmt.Println("命令行参数数量错误,应该是3, 日期,表名 ; 目前长度是:", len(os.Args))
		os.Exit(1)
	}
	for k, v := range os.Args {
		if k == 1 {
			rq = v
		} else if k == 2 {
			tname = v
		}
	}

	//---------break out with vol

	dataMapArray20 := breakwithvol(db, rq, 20, tname)
	dataMapArray30 := append(dataMapArray20, breakwithvol(db, rq, 30, tname)...)
	dataMapArray := append(dataMapArray30, breakwithvol(db, rq, 60, tname)...)
	remark := "Head and shoulders or box pattern wrapped around MA20/30/60/. Auto generated by Plunge"
	cateName := "BreakWithVol" + strings.Replace(rq[5:10], "-", "", -1)
	if len(dataMapArray) > 0 {
		SaveCategoyStockPG(pdb, cateName, cateName, remark, dataMapArray)
	} else {
		fmt.Printf("breakwithvol is nothing")
	}

	end := time.Now().UnixNano()
	fmt.Printf("dltp3l cost is :%d \n", (end-start)/1000)

	//---------getting chips
	dataMapArray = getchips(db, rq, tname)
	cateName = "GetChips" + strings.Replace(rq[5:10], "-", "", -1)
	if len(dataMapArray) > 0 {
		remark = "Getting chips.Auto generated by Plunge "
		SaveCategoyStockPG(pdb, cateName, cateName, remark, dataMapArray)
		fmt.Printf("xc cost is :%d \n", (end-start)/1000)
	} else {
		fmt.Printf("getchips is nothing")
	}
	end = time.Now().UnixNano()

	// // //---------continuous stars
	// cateName = "Stars" + strings.Replace(rq[5:10], "-", "", -1)
	// dataMapArray = stars(db, rq, tname)
	// if len(dataMapArray) > 0 {
	// 	remark = "Continuous stars.Auto generated by Plunge "
	// 	SaveCategoyStockPG(pdb, cateName, cateName, remark, dataMapArray)
	// } else {
	// 	fmt.Printf("Stars is nothing")
	// }

	// // //---------support at the gap
	// cateName = "SuportWithGap" + strings.Replace(rq[5:10], "-", "", -1)
	// dataMapArray = suportwithgap(db, rq, tname)
	// if len(dataMapArray) > 0 {
	// 	remark = "Support at the gap .Auto generated by Plunge "
	// 	SaveCategoyStockPG(pdb, cateName, cateName, remark, dataMapArray)
	// } else {
	// 	fmt.Printf("Suportwithgap is nothing")
	// }
	// end = time.Now().UnixNano()
	// fmt.Printf(" cost is :%d \n", (end-start)/1000)
}
